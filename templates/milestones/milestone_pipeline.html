{% extends 'base.html' %}
{% load static %}

{% block title %}Milestone Pipeline{% endblock %}

{% block stylesheets %}
<style>
  header {
    position: fixed;
  }
  .pipeline-container {
    margin-top: -14%;
    width: 100%;
    overflow-x: auto; /* Allow horizontal scrolling */
    position: relative; /* Needed for tooltip positioning */
    box-sizing: border-box; /* Include padding and border in width and height */
  }
  .link {
    stroke-width: 18px;
    stroke-linecap: round;
    stroke-linejoin: round;
    fill: none;
  }
  .link-end {
    fill: none;
    stroke-width: 12px; /* Increase outer circle ring width */
  }
  .link-end-dot {
    fill: #fff; /* Inner circle color */
  }
  .tooltip {
    position: absolute;
    text-align: center;
    padding: 6px;
    font: 12px sans-serif;
    background: lightsteelblue;
    border: 0px;
    border-radius: 8px;
    pointer-events: none;
  }
</style>
{% endblock stylesheets %}

{% block content %}
<header class="header">
    <h1>
        <i class="bi bi-circle"></i> Milestone Pipeline
    </h1>
</header>

<div id="pipeline" class="pipeline-container"></div>
{% endblock %}

{% block endscript %}
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    const container = document.querySelector('.pipeline-container');
    const containerWidth = container.clientWidth;
    const originalSpacing = 80;
    const spacing = originalSpacing * 2; // Double the spacing
    const milestonesPerRow = 4; // Number of milestones per row

    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    container.appendChild(svg);

    const data = Array.from({ length: 50 }, (_, i) => ({
        text: `Milestone ${i + 1}`,
        completed: i % 2 === 0,
        x: 0,
        y: 0
    }));

    let y = spacing;
    const colors = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"]; // Custom colors

    data.forEach((d, i) => {
        const rowNumber = Math.floor(i / milestonesPerRow) + 1; // Determine row number (1-based)
        const rowWidth = (milestonesPerRow - 1) * spacing; // Width of the row
        const rowStartX = (containerWidth - rowWidth) / 2; // Center row

        if (i % milestonesPerRow === 0) {
            // Move to the next row
            y += spacing;
        }

        // Calculate the x position based on the row number and whether it's odd or even
        const rowOffset = (i % milestonesPerRow) * spacing;
        d.x = rowNumber % 2 === 1 ? rowStartX + rowOffset : rowStartX + rowWidth - rowOffset;
        d.y = y;
    });

    // Calculate SVG height based on the number of rows and add padding
    const rows = Math.ceil(data.length / milestonesPerRow);
    const svgHeight = rows * spacing + spacing * 2; // Adjust height with padding
    svg.setAttribute('width', containerWidth);
    svg.setAttribute('height', svgHeight); // Adjust height

    // Create the stepped paths
    data.slice(1).forEach((d, i) => {
        const previousPoint = data[i];
        let pathData;

        if (previousPoint.y !== d.y) {
            // Create a stepped path to connect rows
            pathData = `M ${previousPoint.x},${previousPoint.y} L ${previousPoint.x},${d.y} L ${d.x},${d.y}`;
        } else {
            // Create a straight line for segments in the same row
            pathData = `M ${previousPoint.x},${previousPoint.y} L ${d.x},${d.y}`;
        }

        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute('class', 'link');
        path.setAttribute('d', pathData);
        path.setAttribute('stroke', colors[i % colors.length]);
        path.setAttribute('stroke-width', '3');
        svg.appendChild(path);
    });

    // Add circular endpoints with outer color and inner white dot
    data.slice(1).forEach((d, i) => {
        const circleOuter = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circleOuter.setAttribute('class', 'link-end');
        circleOuter.setAttribute('cx', d.x);
        circleOuter.setAttribute('cy', d.y);
        circleOuter.setAttribute('r', 14);
        circleOuter.setAttribute('stroke', colors[i % colors.length]);
        svg.appendChild(circleOuter);

        const circleInner = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circleInner.setAttribute('class', 'link-end-dot');
        circleInner.setAttribute('cx', d.x);
        circleInner.setAttribute('cy', d.y);
        circleInner.setAttribute('r', 10);
        svg.appendChild(circleInner);
    });

    // Tooltip
    const tooltip = document.createElement('div');
    tooltip.className = 'tooltip';
    tooltip.style.opacity = 0;
    document.body.appendChild(tooltip);

    svg.querySelectorAll('.link').forEach((link, index) => {
        link.addEventListener('mouseover', function (event) {
            tooltip.style.transition = 'opacity 0.2s';
            tooltip.style.opacity = 0.9;
            tooltip.innerHTML = data[index + 1].text;
            tooltip.style.left = `${event.pageX}px`;
            tooltip.style.top = `${event.pageY - 28}px`;
        });

        link.addEventListener('mouseout', function () {
            tooltip.style.transition = 'opacity 0.5s';
            tooltip.style.opacity = 0;
        });
    });
});


</script>
{% endblock %}
